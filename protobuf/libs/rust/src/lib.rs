use std::{path::PathBuf, sync::{Arc, atomic::AtomicBool}, fmt::Debug};
use anyhow::Context;
use tonic::{body::BoxBody, transport::NamedService};
use warp::http;
use warp::hyper::Body;
use std::{ convert::Infallible, time::Duration, sync::atomic::Ordering::Relaxed };
use tower::Service;

pub mod subprocess;
pub mod unix_socket;

pub mod proto {
    // Common clapshot types
    include!(concat!(env!("OUT_DIR"), "/clapshot.rs"));                     // Generated by [`tonic-build`]
    include!(concat!(env!("OUT_DIR"), "/clapshot.serde.rs"));               // Generated by [`pbjson-build`]
    pub const FILE_DESCRIPTOR_SET: &[u8] = include_bytes!(concat!(env!("OUT_DIR"), "/clapshot_descriptor.bin"));

    // Server <-> organizer communication
    pub mod org {
        include!(concat!(env!("OUT_DIR"), "/clapshot.organizer.rs"));       // Generated by [`tonic-build`]
        include!(concat!(env!("OUT_DIR"), "/clapshot.organizer.serde.rs")); // Generated by [`pbjson-build`]
    }

    // Server <-> client communication
    pub mod client {
        include!(concat!(env!("OUT_DIR"), "/clapshot.client.rs"));          // Generated by [`tonic-build`]
        include!(concat!(env!("OUT_DIR"), "/clapshot.client.serde.rs"));    // Generated by [`pbjson-build`]
    }
}

pub type RpcResult<T> = tonic::Result<tonic::Response<T>, tonic::Status>;


#[derive(Clone)]
pub enum GrpcBindAddr {
    Tcp(std::net::SocketAddr),
    Unix(PathBuf),
}

impl GrpcBindAddr {
    pub fn to_uri(&self) -> String {
        match self {
            GrpcBindAddr::Tcp(s) => format!("http://{}", s),
            GrpcBindAddr::Unix(p) => p.to_string_lossy().into(),
        }
    }
}

impl Debug for GrpcBindAddr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            GrpcBindAddr::Tcp(s) => write!(f, "tcp://{}", s),
            GrpcBindAddr::Unix(p) => write!(f, "unix://{}", p.to_string_lossy()),
        }
    }
}

/// Run a gRPC server.
///
/// # Arguments
///
/// * `bind` - The address to bind to.
/// * `service` - The service to serve.
/// * `span` - The tracing span to use for logging.
/// * `server_listening_flag` - Set to true when the server is ready to accept connections.
/// * `terminate_flag` - A flag that will be checked periodically. When set to true, the server will exit.
pub async fn run_grpc_server<S>(
    bind: GrpcBindAddr,
    service: S,
    span: tracing::Span,
    server_listening_flag: Arc<AtomicBool>,
    terminate_flag: Arc<AtomicBool>) -> anyhow::Result<()>
where
    S: Service<http::Request<Body>, Response = http::Response<BoxBody>, Error = Infallible>
        + NamedService
        + Clone
        + Send
        + 'static,
    S::Future: Send + 'static,
{
    span.in_scope(|| { tracing::info!("Binding to '{:?}'", bind) });

    let refl = tonic_reflection::server::Builder::configure()
        .register_encoded_file_descriptor_set(proto::FILE_DESCRIPTOR_SET)
        .build()?;

    let srv = tonic::transport::Server::builder()
        .add_service(refl)
        .add_service(service);

    let wait_for_shutdown = async move {
        while !terminate_flag.load(Relaxed) { tokio::time::sleep(Duration::from_millis(10)).await; }
    };

    match bind {
        GrpcBindAddr::Tcp(addr) => {
            let listener = tokio::net::TcpListener::bind(&addr).await?;
            let server_stream = tokio_stream::wrappers::TcpListenerStream::new(listener);
            span.in_scope(|| { tracing::debug!("Listening now - TCP on '{}'", addr) });
            server_listening_flag.store(true, Relaxed);
            srv.serve_with_incoming_shutdown(server_stream, wait_for_shutdown).await?;
        },
        GrpcBindAddr::Unix(path) => {
            if path.exists() {
                std::fs::remove_file(&path).context("Failed to delete previous socket.")?;
            }
            let listener = tokio::net::UnixListener::bind(&path)?;
            let server_stream = tokio_stream::wrappers::UnixListenerStream::new(listener);
            span.in_scope(|| { tracing::debug!("Listening now - Unix sock on '{}'", path.to_string_lossy()) });
            server_listening_flag.store(true, Relaxed);
            srv.serve_with_incoming_shutdown(server_stream, wait_for_shutdown).await?;
        }
    }
    span.in_scope(|| { tracing::info!("Exiting gracefully.") });
    Ok(())
}


/// Get a field from a protobuf message, or return Status::invalid_argument if it is not set.

fn _typeof<T>(_: T) -> &'static str { std::any::type_name::<T>() }

#[macro_export]
macro_rules! proto3_get_field {
    ($msg:expr, $field:ident, $err_msg:expr) => {
        $msg.$field.as_ref().ok_or_else(|| {
            Status::invalid_argument($err_msg)
        })
    };
    ($msg:expr, $field:ident) => {
        $msg.$field.as_ref().ok_or_else(|| {
            Status::invalid_argument(format!("Missing '{}' in '{}'", stringify!($field), _typeof($msg)))
        })
    };
}

pub type OrganizerOutboundConnection = proto::org::organizer_outbound_client::OrganizerOutboundClient<tonic::transport::Channel>;

/// Connect to a gRPC server at endpoint given in another `Endpoint` message.
pub async fn connect_back_and_finish_handshake(req: &tonic::Request<proto::org::ServerInfo>)
    -> Result<OrganizerOutboundConnection, tonic::Status>
{
    use proto::org::server_info::grpc_endpoint;
    use tonic::transport::{Channel, Uri};
    use tokio::net::UnixStream;
    use tonic::Status;
    use tower::service_fn;

    // Connect back to server
    let bc = proto3_get_field!(req.get_ref(), backchannel)?;
    let ep = proto3_get_field!(bc, endpoint)?.clone();

    let channel = match ep {
        grpc_endpoint::Endpoint::Unix(unix) =>
        {
            let path = unix.path.clone();
            if !std::path::Path::new(&path).exists() {
                return Err(Status::invalid_argument(format!("Unix socket does not exist: {}", path)));
            }
            const MAX_RETRIES: u32 = 5;
            let mut chan = None;

            for retry in 1..(MAX_RETRIES+1) {
                let path = path.clone();
                chan = match tonic::transport::Endpoint::try_from("file://dummy")
                    .map_err(|e| Status::invalid_argument(format!("Failed to parse org->srv URI: {:?}", e)))?
                    .connect_timeout(std::time::Duration::from_secs(8))
                    .connect_with_connector(service_fn(move |_: Uri| {
                        UnixStream::connect(path.clone()) })).await {
                    Ok(c) => {
                        tracing::info!("Connected back to server (on attempt {retry}/{MAX_RETRIES})");
                        Some(c) },
                    Err(e) => {
                        tracing::warn!("Failed to connect back to server (attempt {retry}/{MAX_RETRIES}): {:?}", e);
                        tokio::time::sleep(std::time::Duration::from_secs_f32(0.5)).await;
                        None
                    }
                };
                if chan.is_some() { break; }
            }

            if let Some(c) = chan { c } else {
                return Err(Status::invalid_argument(format!("UnixStream::connect org->srv failed: connection failed.")));
            }
        },
        grpc_endpoint::Endpoint::Tcp(tcp) =>
        {
            let url = format!("http://{}:{}", tcp.host, tcp.port);
            Channel::from_shared(url)
                .map_err(|e| Status::invalid_argument(format!("Failed to parse org->srv HTTP URI: {:?}", e)))?
                .connect_timeout(std::time::Duration::from_secs(8))
                .connect().await
                .map_err(|e| Status::invalid_argument(format!("HTTP Channel::connect org->srv failed: {:?}", e)))?
        },
    };

    let mut client = OrganizerOutboundConnection::new(channel);
    client.handshake(crate::proto::org::OrganizerInfo {}).await?;

    Ok(client)
}
