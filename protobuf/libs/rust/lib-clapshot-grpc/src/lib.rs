use std::{path::{PathBuf}, sync::{Arc, atomic::AtomicBool}, fmt::Debug};
use anyhow::Context;
use tonic::{body::BoxBody, transport::NamedService};
use warp::http;
use warp::hyper::Body;
use std::{ convert::Infallible, time::Duration, sync::atomic::Ordering::Relaxed };
use tower::Service;

pub mod subprocess;
pub mod unix_socket;

pub mod proto {
    // Generated by [`tonic-build`]
    include!(concat!(env!("OUT_DIR"), "/clapshot.organizer.rs"));
    pub const FILE_DESCRIPTOR_SET: &[u8] = include_bytes!(concat!(env!("OUT_DIR"), "/clapshot_descriptor.bin"));

    // Generated by [`pbjson-build`]
    include!(concat!(env!("OUT_DIR"), "/clapshot.organizer.serde.rs"));
}

pub type RpcResult<T> = tonic::Result<tonic::Response<T>, tonic::Status>;


#[derive(Clone)]
pub enum GrpcBindAddr {
    Tcp(std::net::SocketAddr),
    Unix(PathBuf),
}

impl GrpcBindAddr {
    pub fn to_uri(&self) -> String {
        match self {
            GrpcBindAddr::Tcp(s) => format!("http://{}", s),
            GrpcBindAddr::Unix(p) => p.to_string_lossy().into(),
        }
    }
}

impl Debug for GrpcBindAddr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            GrpcBindAddr::Tcp(s) => write!(f, "tcp://{}", s),
            GrpcBindAddr::Unix(p) => write!(f, "unix://{}", p.to_string_lossy()),
        }
    }
}

/// Run a gRPC server.
/// 
/// # Arguments
/// 
/// * `bind` - The address to bind to.
/// * `service` - The service to serve.
/// * `span` - The tracing span to use for logging.
/// * `terminate_flag` - A flag that will be checked periodically. When set to true, the server will exit.
pub async fn run_grpc_server<S>(
    bind: GrpcBindAddr,
    service: S,
    span: tracing::Span,
    terminate_flag: Arc<AtomicBool>) -> anyhow::Result<()>
where
    S: Service<http::Request<Body>, Response = http::Response<BoxBody>, Error = Infallible>
        + NamedService
        + Clone
        + Send
        + 'static,
    S::Future: Send + 'static,
{
    span.in_scope(|| { tracing::info!("Binding to '{}'", bind.to_uri()) });
    
    let refl = tonic_reflection::server::Builder::configure()
        .register_encoded_file_descriptor_set(proto::FILE_DESCRIPTOR_SET)
        .build()?;

    let srv = tonic::transport::Server::builder()
        .add_service(refl)
        .add_service(service);

    let wait_for_shutdown = async move {
        while !terminate_flag.load(Relaxed) { tokio::time::sleep(Duration::from_millis(10)).await; }
    };

    match bind {
        GrpcBindAddr::Tcp(addr) => {
                srv.serve_with_shutdown(addr, wait_for_shutdown).await?;
        },
        GrpcBindAddr::Unix(path) => {
            if path.exists() {
                std::fs::remove_file(&path).context("Failed to delete previous socket.")?;
            }
            srv.serve_with_incoming_shutdown(
                    tokio_stream::wrappers::UnixListenerStream::new(
                        tokio::net::UnixListener::bind(&path)?),
                    wait_for_shutdown
                ).await?;
        }
    }
    span.in_scope(|| { tracing::info!("Exiting gracefully.") });
    Ok(())
}


/// Get a field from a protobuf message, or return Status::invalid_argument if it is not set.

fn _typeof<T>(_: T) -> &'static str { std::any::type_name::<T>() }

#[macro_export]
macro_rules! proto3_get_field {
    ($msg:expr, $field:ident, $err_msg:expr) => {
        $msg.$field.as_ref().ok_or_else(|| {
            Status::invalid_argument($err_msg)
        })
    };
    ($msg:expr, $field:ident) => {
        $msg.$field.as_ref().ok_or_else(|| {
            Status::invalid_argument(format!("Missing '{}' in '{}'", stringify!($field), _typeof($msg)))
        })
    };
}

pub type OrganizerOutboundConnection = proto::organizer_outbound_client::OrganizerOutboundClient<tonic::transport::Channel>;

/// Connect to a gRPC server at endpoint given in another `Endpoint` message.
pub async fn connect_back_and_finish_handshake(req: &tonic::Request<proto::ServerInfo>)
    -> Result<OrganizerOutboundConnection, tonic::Status>
{
    use proto::server_info::grpc_endpoint;
    use tonic::transport::{Channel, Uri};
    use tokio::net::UnixStream;
    use tonic::Status;
    use tower::service_fn;

    // Connect back to organizer
    let bc = proto3_get_field!(req.get_ref(), backchannel)?;
    let ep = proto3_get_field!(bc, endpoint)?.clone();

    let channel = match ep {
        grpc_endpoint::Endpoint::Unix(unix) =>
        {
            let path = unix.path.clone();
            if !std::path::Path::new(&path).exists() {
                return Err(Status::invalid_argument(format!("Unix socket does not exist: {}", path)));
            }
            tonic::transport::Endpoint::try_from("file://dummy")
                .map_err(|e| Status::invalid_argument(format!("Failed to parse org->srv URI: {:?}", e)))?
                .connect_timeout(std::time::Duration::from_secs(8))
                .connect_with_connector(service_fn(move |_: Uri| {
                    UnixStream::connect(path.clone()) })).await
                    .map_err(|e| Status::invalid_argument(format!("UnixStream::connect org->srv failed: {:?}", e)))?
        },
        grpc_endpoint::Endpoint::Tcp(tcp) =>
        {
            let url = format!("http://{}:{}", tcp.host, tcp.port);
            Channel::from_shared(url)
                .map_err(|e| Status::invalid_argument(format!("Failed to parse org->srv HTTP URI: {:?}", e)))?
                .connect_timeout(std::time::Duration::from_secs(8))
                .connect().await
                .map_err(|e| Status::invalid_argument(format!("HTTP Channel::connect org->srv failed: {:?}", e)))?
        },
    };

    let mut client = OrganizerOutboundConnection::new(channel);
    client.handshake(crate::proto::OrganizerInfo {}).await?;

    Ok(client)
}
